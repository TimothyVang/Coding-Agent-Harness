# Multi-stage Dockerfile Template
# Generated by DevOpsAgent
# Optimized for {{language}} {{framework}} applications

# Stage 1: Build Stage
FROM {{base_image}} AS builder

WORKDIR /app

# Copy dependency files
COPY {{dependency_files}} ./

# Install dependencies
RUN {{install_command}}

# Copy source code
COPY . .

# Build application
RUN {{build_command}}

# Stage 2: Production Stage
FROM {{runtime_image}} AS production

# Set working directory
WORKDIR /app

# Create non-root user for security
RUN addgroup --system --gid 1001 appgroup && \
    adduser --system --uid 1001 --ingroup appgroup appuser

# Copy built artifacts from builder
COPY --from=builder --chown=appuser:appgroup /app/{{build_output}} ./

# Copy production dependencies only (if applicable)
{{#if_node}}
COPY --from=builder --chown=appuser:appgroup /app/node_modules ./node_modules
{{/if_node}}

# Set environment variables
ENV NODE_ENV=production \
    ENVIRONMENT={{environment}} \
    PORT={{port}}

# Expose port
EXPOSE {{port}}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
  CMD {{health_check_command}}

# Switch to non-root user
USER appuser

# Start application
CMD [{{start_command}}]

# ============================================================================
# Language-Specific Examples:
# ============================================================================

# For Node.js:
# - base_image: node:18-alpine
# - runtime_image: node:18-alpine
# - dependency_files: package*.json
# - install_command: npm ci --only=production
# - build_command: npm run build
# - build_output: dist
# - health_check_command: curl -f http://localhost:${PORT}/health || exit 1
# - start_command: "node", "dist/index.js"

# For Python:
# - base_image: python:3.11-slim
# - runtime_image: python:3.11-slim
# - dependency_files: requirements.txt
# - install_command: pip install --no-cache-dir -r requirements.txt
# - build_command: # (optional compilation step)
# - build_output: .
# - health_check_command: curl -f http://localhost:${PORT}/health || exit 1
# - start_command: "python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0"

# For Go:
# - base_image: golang:1.21-alpine
# - runtime_image: alpine:latest
# - dependency_files: go.mod go.sum
# - install_command: go mod download
# - build_command: CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
# - build_output: app
# - health_check_command: /app/app health || exit 1
# - start_command: "./app"

# Best Practices Applied:
# ✓ Multi-stage build for smaller image size
# ✓ Non-root user for security
# ✓ Health check endpoint
# ✓ Proper .dockerignore usage (create separately)
# ✓ Layer caching optimization
# ✓ Security-first approach
